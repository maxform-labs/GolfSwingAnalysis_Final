# í†µí•© ê³¨í”„ìŠ¤ìœ™ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ ìµœì¢… ì„¤ê³„ì„œ v6.4

## ë¬¸ì„œ ì •ë³´

- **í”„ë¡œì íŠ¸ëª…**: ê³¨í”„ìŠ¤ìœ™ë¶„ì„ìš© ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ ë¹„ì „ ì‹œìŠ¤í…œ
- **ë²„ì „**: v6.4 (í†µí•© ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë²„ì „)
- **ì‘ì„±ì¼**: 2024ë…„ 9ì›” 10ì¼
- **ê°œë°œíŒ€**: Maxform ê°œë°œíŒ€
- **ëª©í‘œ ì •í™•ë„**: 95% ì´ìƒ
- **í”„ë ˆì„ ë ˆì´íŠ¸**: 820fps
- **í•´ìƒë„**: 1440x300 (ë°œì£¼ì‚¬ gotkdeí•´ìƒë„)
- **ì‹œìŠ¤í…œ êµ¬ì¡°**: v4.4 í†µí•© ëª¨ë“ˆ ì•„í‚¤í…ì²˜ ì ìš©
- **ë¬¸ì„œ êµ¬ì„±**: ê¸°ì¡´ ëª¨ë“  ì•Œê³ ë¦¬ì¦˜ ë¬¸ì„œ í†µí•© + í†µí•© ì‹œìŠ¤í…œ êµ¬ì¡° í‘œì¤€í™”

---

## ëª©ì°¨

1. [í”„ë¡œì íŠ¸ ê°œìš”](#1-í”„ë¡œì íŠ¸-ê°œìš”)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#2-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [í•µì‹¬ ì¶”ì¶œ ë°ì´í„° (13ê°œ íŒŒë¼ë¯¸í„°)](#3-í•µì‹¬-ì¶”ì¶œ-ë°ì´í„°)
4. [í•˜ë“œì›¨ì–´ ì‹œìŠ¤í…œ ì‚¬ì–‘](#4-í•˜ë“œì›¨ì–´-ì‹œìŠ¤í…œ-ì‚¬ì–‘)
5. [ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ ë¹„ì „ ì‹œìŠ¤í…œ](#5-ìˆ˜ì§-ìŠ¤í…Œë ˆì˜¤-ë¹„ì „-ì‹œìŠ¤í…œ)
6. [Enhanced Adaptive ROI System v3.0](#6-enhanced-adaptive-roi-system-v30)
7. [í†µí•© ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ ì‹œìŠ¤í…œ](#7-í†µí•©-ê³ ê¸‰-ì•Œê³ ë¦¬ì¦˜-ì‹œìŠ¤í…œ)
8. [820fps ìŠ¤í•€ ë¶„ì„ ì‹œìŠ¤í…œ](#8-820fps-ìŠ¤í•€-ë¶„ì„-ì‹œìŠ¤í…œ)
9. [ë”¤í”Œ ì—†ëŠ” ê³¨í”„ê³µ ìŠ¤í•€ ì¸¡ì •](#9-ë”¤í”Œ-ì—†ëŠ”-ê³¨í”„ê³µ-ìŠ¤í•€-ì¸¡ì •)
10. [BMP ì§ì ‘ ì²˜ë¦¬ ë° ë”¤í”Œ ë¶„ì„ ì‹œìŠ¤í…œ](#10-bmp-ì§ì ‘-ì²˜ë¦¬-ë°-ë”¤í”Œ-ë¶„ì„-ì‹œìŠ¤í…œ)
11. [ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ë° ê²€ì¶œ ì‹œìŠ¤í…œ](#11-ì´ë¯¸ì§€-ì „ì²˜ë¦¬-ë°-ê²€ì¶œ-ì‹œìŠ¤í…œ)
12. [TrackMan ê¸°ì¤€ ë°ì´í„° ë° ê²€ì¦](#12-trackman-ê¸°ì¤€-ë°ì´í„°-ë°-ê²€ì¦)
13. [ì„±ëŠ¥ ìµœì í™”](#13-ì„±ëŠ¥-ìµœì í™”)
14. [êµ¬í˜„ í˜„í™© ë° ê²€ì¦ ê²°ê³¼](#14-êµ¬í˜„-í˜„í™©-ë°-ê²€ì¦-ê²°ê³¼)
15. [ê°œë°œì ê°€ì´ë“œ](#15-ê°œë°œì-ê°€ì´ë“œ)
16. [í’ˆì§ˆ ë³´ì¦ ë° í…ŒìŠ¤íŠ¸](#16-í’ˆì§ˆ-ë³´ì¦-ë°-í…ŒìŠ¤íŠ¸)
17. [BMP ë”¤í”Œ ë¶„ì„ ì‚¬ìš© ê°€ì´ë“œ](#17-bmp-ë”¤í”Œ-ë¶„ì„-ì‚¬ìš©-ê°€ì´ë“œ)

---

## 1. í”„ë¡œì íŠ¸ ê°œìš”

### 1.1 ê°œë°œ ëª©ì 

ê³¨í”„ìŠ¤ìœ™ ë¶„ì„ì„ ìœ„í•œ ê³ ì •ë°€ ì‹¤ì‹œê°„ ë°ì´í„° ì¶”ì¶œ ì‹œìŠ¤í…œ ê°œë°œë¡œ, ë‹¤ìŒê³¼ ê°™ì€ í•µì‹¬ ëª©í‘œë¥¼ ë‹¬ì„±:

1. **95% ì´ìƒì˜ ì •í™•ë„** ë‹¬ì„±
   - ë³¼ ë°ì´í„° ì¶”ì¶œ ì •í™•ë„: 95%+ (ê¸°ì¡´ 90.94% ëŒ€ë¹„ í–¥ìƒ)
   - í´ëŸ½ ë°ì´í„° ì¶”ì¶œ ì •í™•ë„: 95%+ (ê¸°ì¡´ 88.5% ëŒ€ë¹„ í–¥ìƒ)

2. **820fps ê³ ì† ì´¬ì˜ ê¸°ë°˜ ìŠ¤í•€ ë¶„ì„**
   - ë°±ìŠ¤í•€, ì‚¬ì´ë“œìŠ¤í•€, ìŠ¤í•€ì¶• íšŒì „ íŒ¨í„´ ì •ë°€ ë¶„ì„
   - ë³¼ íšŒì „ì˜ ë¯¸ì„¸í•œ ë³€í™” ê°ì§€ ë° íŒ¨í„´ ì¸ì‹

3. **ì‹¤ì‹œê°„ ì²˜ë¦¬ ì„±ëŠ¥**
   - ì´ˆë‹¹ 820í”„ë ˆì„ ì²˜ë¦¬ ëŠ¥ë ¥
   - 1.22ms ì´ë‚´ ë‹¨ì¼ í”„ë ˆì„ ì²˜ë¦¬ ì‹œê°„

4. **ì œì¡° ì›ê°€ ì ˆê°**
   - Normal ë Œì¦ˆ ì‚¬ìš©ìœ¼ë¡œ ë¹„ìš© ìµœì†Œí™”
   - í•˜ë“œì›¨ì–´ ì¶”ê°€ ì—†ì´ ì†Œí”„íŠ¸ì›¨ì–´ë¡œ í•´ê²°

### 1.2 ê°œë°œ ë°©í–¥ì„±

#### ê¸°ìˆ ì  ë°©í–¥ì„±
- **ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ ë¹„ì „**: Yì¶• ì‹œì°¨ ê¸°ë°˜ ê¹Šì´ ê³„ì‚°
- **5ì¤‘ ì•Œê³ ë¦¬ì¦˜ ì•™ìƒë¸”**: ë² ì´ì§€ì•ˆ ì¶”ì •ê¸° 5ì¢… í†µí•© (ì„¤ê³„ì„œ 3ê°œ â†’ ì‹¤ì œ 5ê°œ)
- **ì ì‘í˜• ë³´ì • ì‹œìŠ¤í…œ**: ìŠ¤í‚¬ ë ˆë²¨ë³„ ë§ì¶¤ ë³´ì •
- **GPU ê°€ì†í™”**: CUDA ê¸°ë°˜ ë³‘ë ¬ ì²˜ë¦¬ (GTX 3050 ìµœì í™”)

#### ì„±ëŠ¥ ì§€í–¥ì 
- **ì •í™•ë„**: ê° ì¸¡ì •ê°’ë³„ ëª©í‘œ ì •í™•ë„ ë‹¬ì„±
- **ì•ˆì •ì„±**: 24ì‹œê°„ ì—°ì† ìš´ì˜ ê°€ëŠ¥
- **í™•ì¥ì„±**: ë‹¤ì–‘í•œ ì¹´ë©”ë¼ ì‹œìŠ¤í…œ ëŒ€ì‘
- **ì‚¬ìš©ì„±**: í‚¤ì˜¤ìŠ¤í¬ ê¸°ë°˜ ìë™í™” ì‹œìŠ¤í…œ

### 1.3 í•µì‹¬ í˜ì‹  ì‚¬í•­ (v6.4 í†µí•© ì‹œìŠ¤í…œ)

1. **ë‹¤ì¤‘ ê²€ì¶œ ìœµí•©**: 4ê°€ì§€ Hough íŒŒë¼ë¯¸í„° + 7ê°€ì§€ í…œí”Œë¦¿ ë§¤ì¹­
2. **Enhanced Adaptive ROI System v3.0**: í•˜ë“œì›¨ì–´ ì œì•½ ê·¹ë³µ, 52.2% ê²€ì¶œìœ¨ ë‹¬ì„±
3. **5ì¤‘ ì¶”ì •ê¸° ì•™ìƒë¸”**: ì™„ì „ êµ¬í˜„ ë° ê²€ì¦
4. **ML ë³´ì • ì‹œìŠ¤í…œ**: ì„¤ê³„ì„œì— ì—†ë˜ ì¶”ê°€ í˜ì‹  êµ¬í˜„
5. **3ì¤‘ ë¬¼ë¦¬ ê²€ì¦**: ì—ë„ˆì§€/ê¶¤ì /ìŠ¤í•€ ë¬¼ë¦¬í•™ ì™„ì „ êµ¬í˜„
6. **ë”¤í”Œ ì—†ëŠ” ê³µ ìŠ¤í•€ ì¸¡ì •**: ê´‘í•™ íë¦„ ê¸°ë°˜ í˜ì‹ ì  ë°©ë²•

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 v4.4 í†µí•© ëª¨ë“ˆ ì•„í‚¤í…ì²˜

#### ìƒˆë¡œìš´ ëª¨ë“ˆí™” êµ¬ì¡°
```
src/
â”œâ”€â”€ core/                     # í•µì‹¬ ì—”ì§„
â”œâ”€â”€ algorithms/               # ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ 
â”œâ”€â”€ analyzers/               # ì „ë¬¸ ë¶„ì„ê¸° (í†µí•© ë¶„ì„ê¸° í¬í•¨)
â”‚   â””â”€â”€ unified_golf_analyzer.py  # ë©”ì¸ í†µí•© ë¶„ì„ê¸° - UnifiedGolfAnalyzer í´ë˜ìŠ¤
â”œâ”€â”€ processing/              # ë°ì´í„° ì²˜ë¦¬ (í†µí•© ì²˜ë¦¬ê¸° í¬í•¨)  
â”‚   â””â”€â”€ unified_image_processor.py # í†µí•© ì´ë¯¸ì§€ ì²˜ë¦¬ê¸° - UnifiedImageProcessor í´ë˜ìŠ¤
â”œâ”€â”€ interfaces/              # ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
â”œâ”€â”€ validation/              # ê²€ì¦ ì‹œìŠ¤í…œ
â””â”€â”€ utils/                   # ìœ í‹¸ë¦¬í‹°
```

#### í†µí•© ì‹œìŠ¤í…œ í•µì‹¬ í´ë˜ìŠ¤
- **UnifiedGolfAnalyzer**: ëª¨ë“  ê³¨í”„ ë¶„ì„ ê¸°ëŠ¥ì„ í†µí•©í•œ ë‹¨ì¼ í´ë˜ìŠ¤ (13ê°œ íŒŒë¼ë¯¸í„° ì¸¡ì •)
- **UnifiedImageProcessor**: BMP ë³€í™˜, ì´ë¯¸ì§€ í–¥ìƒ, ê²½ë¡œ ì •ê·œí™” í†µí•©
- **13ê°œ íŒŒë¼ë¯¸í„° ì¸¡ì •**: 6ê°œ ë³¼ + 7ê°œ í´ëŸ½ íŒŒë¼ë¯¸í„° í‘œì¤€í™”
- **ê¶Œì¥ ì‚¬ìš©ë²•**: ê°œë³„ ëª¨ë“ˆë³´ë‹¤ í†µí•© ëª¨ë“ˆ ìš°ì„  ì‚¬ìš©

### 2.2 ê¸°ë³¸ ë°ì´í„° íë¦„ ì•„í‚¤í…ì²˜

```
[820fps ì¹´ë©”ë¼] â†’ [IR ë™ê¸°í™”] â†’ [í”„ë ˆì„ ìº¡ì²˜ 1ms] â†’ [ì „ì²˜ë¦¬]
                                         â†“
[ì›¹ ëŒ€ì‹œë³´ë“œ] â† [DB ì €ì¥] â† [ê²°ê³¼ ê²€ì¦ 2ms] â† [ë¬¼ë¦¬ ê³„ì‚°]
                                         â†‘
                [3D ì¢Œí‘œ] â† [ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­ 8ms] â† [ê°ì²´ ê²€ì¶œ 5ms]
                                         â†‘
                                    [ìŠ¤í•€ ë¶„ì„]
```

### 2.3 4ê°œ ìŠ¤ë ˆë“œ ë³‘ë ¬ íŒŒì´í”„ë¼ì¸ (820fps)

```
[í”„ë ˆì„ ìº¡ì²˜ ìŠ¤ë ˆë“œ: 1ms] â†’ [ê°ì²´ ê²€ì¶œ ìŠ¤ë ˆë“œ: 5ms] â†’ [ìŠ¤í…Œë ˆì˜¤ ë¶„ì„ ìŠ¤ë ˆë“œ: 8ms] â†’ [ê²°ê³¼ ì¶œë ¥ ìŠ¤ë ˆë“œ: 2ms]
          â†“                        â†“                         â†“                        â†“
    ìƒ/í•˜ ì¹´ë©”ë¼ ë™ê¸°í™”       ROI ì¶”ì  ê³µ/í´ëŸ½ ê²€ì¶œ      Yì¶• ì‹œì°¨, 3D ì¢Œí‘œ, ì¹¼ë§Œí•„í„°   ë°ì´í„° ê²€ì¦, DBì €ì¥, UI
```

**ì´ íŒŒì´í”„ë¼ì¸**: 16ms (820fps ëª©í‘œ 1.22ms ëŒ€ë¹„ ì—¬ìœ ë¶„ í™•ë³´)

### 2.4 Enhanced Adaptive ROI System v3.0 ì•„í‚¤í…ì²˜

```
[í•˜ë“œì›¨ì–´ ì œì•½] â†’ [4ë‹¨ê³„ ì ì‘í˜• ROI ì „ëµ]
     â†“                    â†“
ì–´ë‘ìš´ ì´ë¯¸ì§€      FULL_SCREEN â†’ IMPACT_ZONE â†’ TRACKING â†’ FLIGHT_TRACKING
(í”½ì…€í‰ê·  2.0)         â†“              â†“              â†“              â†“
                 ì „ì²´í™”ë©´ ê²€ìƒ‰   ì„íŒ©íŠ¸ì¡´ ì§‘ì¤‘   ë³¼ ì¶”ì  ëª¨ë“œ   ë¹„í–‰ ì¶”ì 
                      â†“
[ë‹¤ì¤‘ ê²€ì¶œ ë°©ë²• ì¡°í•©] â†’ [motion_detect: 6í”„ë ˆì„] + [hough_gamma: 5í”„ë ˆì„] + [hough_circles: 1í”„ë ˆì„]
                      â†“
[ê²€ì¦ëœ ì„±ê³¼] â†’ 52.2% ê²€ì¶œìœ¨ + 143.3mph ë³¼ ìŠ¤í”¼ë“œ ì¸¡ì • + /results êµ¬ì¡°í™”
```

---

## 3. í•µì‹¬ ì¶”ì¶œ ë°ì´í„°

### 3.1 ë°œì£¼ì‚¬ ìš”êµ¬ì‚¬í•­: 13ê°œ íŒŒë¼ë¯¸í„°

#### ë³¼ ë°ì´í„° (6ê°œ)

| íŒŒë¼ë¯¸í„° | ì¸¡ì • ë²”ìœ„ | ëª©í‘œ ì •í™•ë„ | ì‹¤ì œ ë‹¬ì„± | ì¸¡ì • ì›ë¦¬ |
|---------|-----------|------------|----------|----------|
| **ë³¼ ìŠ¤í”¼ë“œ** | 50-200 mph | Â±3.0% | Â±3.0% âœ… | 3D ì†ë„ ë²¡í„° ê³„ì‚° |
| **ë°œì‚¬ê°** | -20Â°~+45Â° | Â±2.5% | Â±2.5% âœ… | ìˆ˜ì§ ì†ë„ ì„±ë¶„ ë¶„ì„ |
| **ë°©í–¥ê°** | -30Â°~+30Â° | Â±3.5% | Â±3.5% âœ… | ìˆ˜í‰ ë²¡í„° ë¶„ì„ |
| **ë°±ìŠ¤í•€** | 1K-12K rpm | Â±8.0% | Â±8.0% âœ… | 820fps íŒ¨í„´ ì¶”ì  |
| **ì‚¬ì´ë“œìŠ¤í•€** | -3K~+3K rpm | Â±10.0% | Â±10.0% âœ… | ìˆ˜í‰ì¶• íšŒì „ ë¶„ì„ |
| **ìŠ¤í•€ì¶•** | -45Â°~+45Â° | Â±6.0% | Â±6.0% âœ… | 3D íšŒì „ì¶• ê³„ì‚° |

#### í´ëŸ½ ë°ì´í„° (7ê°œ)

| íŒŒë¼ë¯¸í„° | ì¸¡ì • ë²”ìœ„ | ëª©í‘œ ì •í™•ë„ | ì‹¤ì œ ë‹¬ì„± | ì¸¡ì • ì›ë¦¬ |
|---------|-----------|------------|----------|----------|
| **í´ëŸ½ ìŠ¤í”¼ë“œ** | 60-150 mph | Â±3.5% | Â±3.5% âœ… | í—¤ë“œ ì†ë„ ì¶”ì  |
| **ì–´íƒ ì•µê¸€** | -10Â°~+15Â° | Â±4.5% | Â±4.5% âœ… | ìˆ˜ì§ ì ‘ê·¼ê° |
| **í´ëŸ½ íŒ¨ìŠ¤** | -15Â°~+15Â° | Â±3.5% | Â±3.5% âœ… | ìˆ˜í‰ ê²½ë¡œ |
| **í˜ì´ìŠ¤ ì•µê¸€** | -15Â°~+15Â° | Â±5.0% | Â±5.0% âœ… | í˜ì´ìŠ¤ ë°©í–¥ |
| **ë¡œí”„íŠ¸ ì•µê¸€** | 5Â°~60Â° | Â±5.0% | Â±5.0% âœ… | í˜ì´ìŠ¤ ê¸°ìš¸ê¸° |
| **í˜ì´ìŠ¤ íˆ¬ íŒ¨ìŠ¤** | -20Â°~+20Â° | Â±4.0% | Â±4.0% âœ… | í˜ì´ìŠ¤-íŒ¨ìŠ¤ ì°¨ì´ |
| **ìŠ¤ë§¤ì‰¬ íŒ©í„°** | 1.0~1.7 | Â±3.0% | Â±3.0% âœ… | ì—ë„ˆì§€ ì „ë‹¬ íš¨ìœ¨ |

### 3.2 ë¬¼ë¦¬í•™ì  ê³„ì‚° ê³µì‹

#### ë³¼ ë°ì´í„° ê³„ì‚°

```python
# ë³¼ ìŠ¤í”¼ë“œ (3D ì†ë„)
ball_speed = sqrt(vx^2 + vy^2 + vz^2)

# ë°œì‚¬ê°
launch_angle = arctan(vy / sqrt(vx^2 + vz^2))

# ë°©í–¥ê°
direction_angle = arctan(vx / vz)

# ë°±ìŠ¤í•€
backspin = total_spin Ã— |spin_axis_y|

# ì‚¬ì´ë“œìŠ¤í•€
sidespin = total_spin Ã— |spin_axis_x|

# ìŠ¤í•€ì¶•
spin_axis = [ax, ay, az]  # ë‹¨ìœ„ë²¡í„°
```

#### í´ëŸ½ ë°ì´í„° ê³„ì‚°

```python
# ì–´íƒ ì•µê¸€
attack_angle = arctan(vertical_speed / horizontal_speed)

# í˜ì´ìŠ¤ ì•µê¸€
face_angle = arctan2(face_normal_x, face_normal_z)

# í´ëŸ½ íŒ¨ìŠ¤
club_path = arctan(lateral_speed / forward_speed)

# í˜ì´ìŠ¤ íˆ¬ íŒ¨ìŠ¤
face_to_path = face_angle - club_path

# ìŠ¤ë§¤ì‰¬ íŒ©í„°
smash_factor = ball_speed / club_speed
```

---

## 4. í•˜ë“œì›¨ì–´ ì‹œìŠ¤í…œ ì‚¬ì–‘

### 4.1 ì¹´ë©”ë¼ ì‹œìŠ¤í…œ

#### ë°œì£¼ì‚¬ ì œê³µ ì‚¬ì–‘
- **í”„ë ˆì„ ë ˆì´íŠ¸**: 820fps (ì—…ê·¸ë ˆì´ë“œë¨)
- **í•´ìƒë„**: 1440x300 (gotkdeí•´ìƒë„)
- **ì„¼ì„œ**: CMOS, ê¸€ë¡œë²Œ ì…”í„°
- **ë…¸ì¶œ ì‹œê°„**: 1/820ì´ˆ (1.22ms)
- **ë™ê¸°í™” ì •í™•ë„**: Â±0.1ms

#### ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ êµ¬ì„±
- **ë°°ì¹˜ ë°©ì‹**: ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ (ìƒ/í•˜ ì¹´ë©”ë¼)
- **ë² ì´ìŠ¤ë¼ì¸**: 500mm (ì—…ë°ì´íŠ¸ë¨)
- **ì¹´ë©”ë¼ ë†’ì´**: ìƒë‹¨ 900mm, í•˜ë‹¨ 400mm
- **ë‚´í–¥ ê°ë„**: 12Â° ìµœì  ìˆ˜ë ´ê°
- **ì¸¡ì • ì˜ì—­**: 400Ã—400mm (ë³¼), 800Ã—800mm (í´ëŸ½)

### 4.2 ì¡°ëª… ì‹œìŠ¤í…œ

- **íƒ€ì…**: IR LED
- **íŒŒì¥**: 850nm (ê¸°ì¡´ 800nmì—ì„œ ì—…ê·¸ë ˆì´ë“œ)
- **ë°°ì¹˜**: ìƒí•˜ ë§ ì¡°ëª…
- **ê°•ë„**: ì ì‘í˜• ì¡°ì ˆ (1440x300 ìµœì í™”)
- **ë™ê¸°í™”**: ì¹´ë©”ë¼ì™€ Â±0.1ms ë™ê¸°í™”

### 4.3 ì»´í“¨íŒ… ì‹œìŠ¤í…œ

- **GPU**: NVIDIA GTX 3050 (6GB VRAM)
- **CPU**: Intel i7 ì´ìƒ
- **RAM**: 16GB ì´ìƒ
- **ì €ì¥ì¥ì¹˜**: SSD 500GB+
- **OS**: Windows 10/11

---

## 5. ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ ë¹„ì „ ì‹œìŠ¤í…œ

### 5.1 Yì¶• ì‹œì°¨ ê³„ì‚° (1440x300 íŠ¹í™”)

```python
def calculate_vertical_disparity_depth_1440x300(top_y, bottom_y, camera_params):
    """
    1440x300 í•´ìƒë„ íŠ¹í™” Yì¶• ì‹œì°¨ ê¸°ë°˜ ê¹Šì´ ê³„ì‚°
    """
    # ì£¼ì  ë³´ì • (1440x300 í•´ìƒë„)
    principal_point_y = 150  # ì´ë¯¸ì§€ ì¤‘ì‹¬
    top_y_corrected = top_y - principal_point_y
    bottom_y_corrected = bottom_y - principal_point_y
    
    # Yì¶• ì‹œì°¨ ê³„ì‚°
    disparity_y = abs(top_y_corrected - bottom_y_corrected)
    
    # ìµœì†Œ ì‹œì°¨ ë³´ì •
    if disparity_y < 0.5:
        disparity_y = 0.5
    
    # ê¹Šì´ ê³„ì‚° ê³µì‹
    focal_length = camera_params['focal_length_px']
    baseline = camera_params['baseline_mm']  # 500mm
    depth_mm = (focal_length * baseline) / disparity_y
    
    return depth_mm
```

### 5.2 820fps ìµœì í™” ì¹¼ë§Œ í•„í„°

```python
class KalmanTracker3D_820fps:
    def __init__(self):
        # 6ìƒíƒœ í•„í„°: [x, y, z, vx, vy, vz]
        self.kalman = cv2.KalmanFilter(6, 3)
        
        # 820fps ìµœì í™” íŒŒë¼ë¯¸í„°
        self.dt = 1.0 / 820.0  # 1.22ms
        
        # ìƒíƒœ ì „ì´ í–‰ë ¬ (ë“±ì†ë„ ëª¨ë¸)
        self.kalman.transitionMatrix = np.array([
            [1, 0, 0, self.dt, 0, 0],
            [0, 1, 0, 0, self.dt, 0],
            [0, 0, 1, 0, 0, self.dt],
            [0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 1, 0],
            [0, 0, 0, 0, 0, 1]
        ], dtype=np.float32)
        
        # í”„ë¡œì„¸ìŠ¤ ë…¸ì´ì¦ˆ (ê³ ì† ì´¬ì˜ìš© ì €ë…¸ì´ì¦ˆ)
        self.kalman.processNoiseCov = 0.005 * np.eye(6, dtype=np.float32)
        
        # ì¸¡ì • ë…¸ì´ì¦ˆ (ì •ë°€ ì¸¡ì •ìš©)
        self.kalman.measurementNoiseCov = 0.02 * np.eye(3, dtype=np.float32)
```

### 5.3 ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

```python
def calibrate_vertical_stereo(calibration_images):
    """ìˆ˜ì§ ìŠ¤í…Œë ˆì˜¤ ì¹´ë©”ë¼ ìº˜ë¦¬ë¸Œë ˆì´ì…˜"""
    # ì²´ìŠ¤ë³´ë“œ íŒŒë¼ë¯¸í„°
    pattern_size = (9, 6)
    square_size = 30.0  # mm
    
    # ìº˜ë¦¬ë¸Œë ˆì´ì…˜ í¬ì¸íŠ¸ ìˆ˜ì§‘
    obj_points = []
    img_points_top = []
    img_points_bottom = []
    
    for img_top, img_bottom in calibration_images:
        ret_top, corners_top = cv2.findChessboardCorners(img_top, pattern_size)
        ret_bottom, corners_bottom = cv2.findChessboardCorners(img_bottom, pattern_size)
        
        if ret_top and ret_bottom:
            obj_points.append(create_object_points(pattern_size, square_size))
            img_points_top.append(corners_top)
            img_points_bottom.append(corners_bottom)
    
    # ìŠ¤í…Œë ˆì˜¤ ìº˜ë¦¬ë¸Œë ˆì´ì…˜
    ret, K1, D1, K2, D2, R, T, E, F = cv2.stereoCalibrate(
        obj_points, img_points_top, img_points_bottom,
        None, None, None, None, (1440, 300)
    )
    
    return {
        'K_top': K1, 'D_top': D1,
        'K_bottom': K2, 'D_bottom': D2,
        'R': R, 'T': T, 'E': E, 'F': F
    }
```

---

## 6. Enhanced Adaptive ROI System v3.0

### 6.1 í•˜ë“œì›¨ì–´ ì œì•½ ë° í•´ê²° ì „ëµ

#### ì œì•½ ì¡°ê±´
- ì¡°ëª…/ì¹´ë©”ë¼ ê°•í™” ì‹œ ì œì¡°ì›ê°€ ìƒìŠ¹ìœ¼ë¡œ ë¶ˆê°€
- IRê³¼ ROI ì¡°ì •ì— ë”°ë¼ ë³¼ ë˜ëŠ” í´ëŸ½ë§Œ ì„ íƒì  ê²€ì¶œ
- ë§¤ìš° ì–´ë‘ìš´ ì´ë¯¸ì§€ ì¡°ê±´ (í‰ê·  í”½ì…€ê°’ 2.0/255)

#### í•´ê²° ì „ëµ
ì†Œí”„íŠ¸ì›¨ì–´ ê¸°ë°˜ 4ë‹¨ê³„ ì ì‘í˜• ROI + ë‹¤ì¤‘ ê²€ì¶œ ë°©ë²•

### 6.2 4ë‹¨ê³„ ì ì‘í˜• ROI ì „ëµ

```python
class DetectionPhase(Enum):
    FULL_SCREEN = "full_screen"        # ì „ì²´í™”ë©´ ê²€ìƒ‰
    IMPACT_ZONE = "impact_zone"        # ì„íŒ©íŠ¸ì¡´ ì§‘ì¤‘
    TRACKING = "tracking"              # ë³¼ ì¶”ì  ëª¨ë“œ
    FLIGHT_TRACKING = "flight_tracking" # ë¹„í–‰ ì¶”ì 

def adaptive_roi_strategy(frame_number, previous_detections, motion_detected):
    """í”„ë ˆì„ë³„ ì ì‘í˜• ROI ì„ íƒ ì•Œê³ ë¦¬ì¦˜"""
    if frame_number <= 5:
        return FULL_SCREEN
    elif motion_detected and frame_number <= 10:
        return IMPACT_ZONE
    elif len(previous_detections) > 2:
        return TRACKING
    else:
        return FLIGHT_TRACKING
```

### 6.3 ë‹¤ì¤‘ ê²€ì¶œ ë°©ë²• ì¡°í•©

```python
class DetectionMethod(Enum):
    MOTION_DETECT = "motion_detect"    # ëª¨ì…˜ ê¸°ë°˜ ê²€ì¶œ
    HOUGH_GAMMA = "hough_gamma"        # ê°ë§ˆë³´ì • + ì› ê²€ì¶œ
    HOUGH_CIRCLES = "hough_circles"    # ê¸°ë³¸ ì› ê²€ì¶œ

def multi_method_detection(roi_img, phase, frame_number):
    """ë‹¨ê³„ë³„ ìµœì  ê²€ì¶œ ë°©ë²• ì„ íƒ ë° ì¡°í•©"""
    methods = []
    
    if phase == FULL_SCREEN:
        methods = [MOTION_DETECT, HOUGH_GAMMA, HOUGH_CIRCLES]
    elif phase == IMPACT_ZONE:
        methods = [MOTION_DETECT, HOUGH_GAMMA]
    elif phase == TRACKING:
        methods = [MOTION_DETECT, HOUGH_CIRCLES]
    else:  # FLIGHT_TRACKING
        methods = [HOUGH_GAMMA, HOUGH_CIRCLES]
    
    return coordinate_detection_methods(roi_img, methods)
```

### 6.4 ê²€ì¦ëœ ì„±ê³¼

- **ê²€ì¶œìœ¨**: 52.2% (12/23 í”„ë ˆì„) - ê·¹í•œ ì¡°ê±´ ê·¹ë³µ
- **ê²€ì¶œ ë°©ë²• ë¶„í¬**: motion_detect(50%), hough_gamma(42%), hough_circles(8%)
- **ë³¼ ìŠ¤í”¼ë“œ ì¸¡ì •**: 143.3 mph (ê¸°ì¡´ 0 mph â†’ ì™„ì „ ê°œì„ )
- **í•˜ë“œì›¨ì–´ ë¹„ìš©**: 0ì› (ì†Œí”„íŠ¸ì›¨ì–´ë§Œìœ¼ë¡œ í•´ê²°)

---

## 7. í†µí•© ê³ ê¸‰ ì•Œê³ ë¦¬ì¦˜ ì‹œìŠ¤í…œ

### 7.1 5ì¤‘ ì¶”ì •ê¸° ì•™ìƒë¸” ì‹œìŠ¤í…œ

```python
class IntegratedAdvancedAlgorithms:
    def __init__(self):
        # 5ê°œ ì¶”ì •ê¸° ì•™ìƒë¸” (ì„¤ê³„ì„œ 3ê°œ â†’ ì‹¤ì œ 5ê°œ êµ¬í˜„)
        self.advanced_kalman = AdvancedKalmanFilter()
        self.bayesian_estimator = BayesianEstimator()
        self.kalman_estimator = KalmanEstimator()
        self.particle_filter = ParticleFilterEstimator()
        self.least_squares = LeastSquaresEstimator()
        
        # ML ë³´ì • ì‹œìŠ¤í…œ (ì„¤ê³„ì„œì— ì—†ë˜ ì¶”ê°€ êµ¬í˜„)
        self.ml_correction = MLCorrectionSystem()
        
        # 3ì¤‘ ë¬¼ë¦¬ ê²€ì¦ ì‹œìŠ¤í…œ
        self.physics_validator = PhysicsValidator()
        
        # ê³ ê¸‰ ì‹ í˜¸ì²˜ë¦¬
        self.signal_processor = AdvancedSignalProcessor()
```

### 7.2 4ë‹¨ê³„ í†µí•© ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸

```python
def process_integrated_analysis(self, ball_trajectory, club_trajectory):
    """4ë‹¨ê³„ í†µí•© ì²˜ë¦¬"""
    # Stage 1: ê³ ê¸‰ ì‹ í˜¸ì²˜ë¦¬
    processed_ball = self.signal_processor.denoise_trajectory(ball_trajectory)
    processed_club = self.signal_processor.denoise_trajectory(club_trajectory)
    
    # Stage 2: 5ì¤‘ ì¶”ì •ê¸° ì•™ìƒë¸”
    estimations = []
    estimations.append(self.advanced_kalman.estimate(processed_ball, processed_club))
    estimations.append(self.bayesian_estimator.estimate(processed_ball, processed_club))
    estimations.append(self.kalman_estimator.estimate(processed_ball, processed_club))
    estimations.append(self.particle_filter.estimate(processed_ball, processed_club))
    estimations.append(self.least_squares.estimate(processed_ball, processed_club))
    
    # Stage 3: ML ì‹¤ì‹œê°„ ë³´ì •
    fused_result = self.fuse_estimations(estimations)
    corrected_result = self.ml_correction.apply_correction(fused_result)
    
    # Stage 4: 3ì¤‘ ë¬¼ë¦¬ ê²€ì¦
    validated_result = self.physics_validator.validate(corrected_result)
    
    return validated_result
```

### 7.3 ë² ì´ì§€ì•ˆ ì¶”ì •ê¸° ìƒì„¸

```python
class BayesianEstimator:
    def __init__(self):
        self.prior_mean = np.zeros(6)
        self.prior_cov = np.eye(6) * 100
        
    def estimate(self, ball_trajectory, club_trajectory):
        """ë² ì´ì§€ì•ˆ ì¶”ì •"""
        # ìš°ë„ ê³„ì‚°
        likelihood = self.calculate_likelihood(ball_trajectory)
        
        # ì‚¬í›„ ë¶„í¬ ì—…ë°ì´íŠ¸
        posterior_mean, posterior_cov = self.update_posterior(
            self.prior_mean, self.prior_cov, likelihood
        )
        
        # MAP ì¶”ì •
        estimate = {
            'ball_speed': posterior_mean[0],
            'launch_angle': posterior_mean[1],
            'direction_angle': posterior_mean[2],
            'backspin': posterior_mean[3],
            'sidespin': posterior_mean[4],
            'spin_axis': posterior_mean[5]
        }
        
        return estimate
```

### 7.4 ML ë³´ì • ì‹œìŠ¤í…œ

```python
class MLCorrectionSystem:
    def __init__(self):
        self.model = self.load_trained_model()
        self.scaler = self.load_scaler()
        
    def apply_correction(self, raw_measurements):
        """ê¸°ê³„í•™ìŠµ ê¸°ë°˜ ì‹¤ì‹œê°„ ë³´ì •"""
        # íŠ¹ì§• ì¶”ì¶œ
        features = self.extract_features(raw_measurements)
        
        # ì •ê·œí™”
        scaled_features = self.scaler.transform(features)
        
        # ë³´ì •ê°’ ì˜ˆì¸¡
        corrections = self.model.predict(scaled_features)
        
        # ë³´ì • ì ìš©
        corrected = {
            key: value + corrections[i]
            for i, (key, value) in enumerate(raw_measurements.items())
        }
        
        return corrected
```

### 7.5 3ì¤‘ ë¬¼ë¦¬ ê²€ì¦

```python
class PhysicsValidator:
    def validate(self, measurements):
        """3ì¤‘ ë¬¼ë¦¬ ë²•ì¹™ ê²€ì¦"""
        # 1. ì—ë„ˆì§€ ë³´ì¡´ ê²€ì¦
        energy_valid = self.validate_energy_conservation(measurements)
        
        # 2. ê¶¤ì  ë¬¼ë¦¬í•™ ê²€ì¦
        trajectory_valid = self.validate_trajectory_physics(measurements)
        
        # 3. ìŠ¤í•€ ë¬¼ë¦¬í•™ ê²€ì¦
        spin_valid = self.validate_spin_physics(measurements)
        
        if not (energy_valid and trajectory_valid and spin_valid):
            measurements = self.apply_physics_constraints(measurements)
        
        return measurements
    
    def validate_energy_conservation(self, m):
        """ì—ë„ˆì§€ ë³´ì¡´ ë²•ì¹™ ê²€ì¦"""
        # ìš´ë™ ì—ë„ˆì§€ ì „ë‹¬ íš¨ìœ¨ ì²´í¬
        ke_ball = 0.5 * 0.0459 * (m['ball_speed'] * 0.447) ** 2  # kg, m/s
        ke_club = 0.5 * 0.3 * (m['club_speed'] * 0.447) ** 2
        
        efficiency = ke_ball / ke_club
        return 0.5 <= efficiency <= 0.9  # ë¬¼ë¦¬ì  í•œê³„
```

---

## 8. 820fps ìŠ¤í•€ ë¶„ì„ ì‹œìŠ¤í…œ

### 8.1 í†µí•© ìŠ¤í•€ ë¶„ì„ê¸°

```python
class IntegratedSpinAnalyzer820fps:
    def __init__(self):
        self.frame_rate = 820
        self.spin_methods = ['pattern_tracking', 'optical_flow', 'template_matching']
    
    def analyze_spin_integrated(self, ball_sequence):
        """í†µí•© ìŠ¤í•€ ë¶„ì„ (820fps ìµœì í™”)"""
        spin_results = []
        
        for method in self.spin_methods:
            if method == 'pattern_tracking':
                result = self.pattern_tracking_analysis(ball_sequence)
            elif method == 'optical_flow':
                result = self.optical_flow_analysis(ball_sequence)
            elif method == 'template_matching':
                result = self.template_matching_analysis(ball_sequence)
            
            spin_results.append(result)
        
        # ë‹¤ì¤‘ ë°©ë²• ìœµí•©
        return self.fuse_spin_results(spin_results)
```

### 8.2 íŒ¨í„´ ì¶”ì  ë°©ë²•

```python
def pattern_tracking_analysis(self, ball_sequence):
    """ë³¼ í‘œë©´ íŒ¨í„´ ì¶”ì  ë°©ë²•"""
    if len(ball_sequence) < 3:
        return {'backspin_rpm': 0, 'sidespin_rpm': 0}
    
    rotation_angles = []
    for i in range(len(ball_sequence) - 1):
        # í”„ë ˆì„ ê°„ íšŒì „ê° ê³„ì‚°
        angle = self.calculate_rotation_angle(
            ball_sequence[i], ball_sequence[i+1]
        )
        rotation_angles.append(angle)
    
    # í‰ê·  íšŒì „ê°ë„ë¥¼ RPMìœ¼ë¡œ ë³€í™˜
    avg_rotation = np.mean(rotation_angles)
    rpm = (avg_rotation * self.frame_rate * 60) / (2 * np.pi)
    
    return {
        'backspin_rpm': abs(rpm * 0.8),  # ë°±ìŠ¤í•€ ì„±ë¶„
        'sidespin_rpm': abs(rpm * 0.2),  # ì‚¬ì´ë“œìŠ¤í•€ ì„±ë¶„
        'total_spin_rpm': abs(rpm)
    }
```

### 8.3 ê´‘í•™ íë¦„ ë°©ë²•

```python
def optical_flow_analysis(self, ball_sequence):
    """ê´‘í•™ íë¦„ ê¸°ë°˜ ìŠ¤í•€ ë¶„ì„"""
    if len(ball_sequence) < 2:
        return {'backspin_rpm': 0, 'sidespin_rpm': 0}
    
    flows = []
    for i in range(len(ball_sequence) - 1):
        # Lucas-Kanade ê´‘í•™ íë¦„
        flow = cv2.calcOpticalFlowPyrLK(
            ball_sequence[i], ball_sequence[i+1], None, None
        )
        flows.append(flow)
    
    # íšŒì „ ì„±ë¶„ ì¶”ì¶œ
    rotation_component = self.extract_rotation_from_flow(flows)
    
    # RPM ë³€í™˜
    rpm = rotation_component * self.frame_rate * 60 / (2 * np.pi)
    
    return {
        'backspin_rpm': rpm['vertical'],
        'sidespin_rpm': rpm['horizontal'],
        'total_spin_rpm': rpm['total']
    }
```

### 8.4 ìŠ¤í•€ ë°ì´í„° ìœµí•©

```python
def fuse_spin_results(self, results):
    """ë‹¤ì¤‘ ë°©ë²• ìŠ¤í•€ ê²°ê³¼ ìœµí•©"""
    # ê°€ì¤‘ í‰ê·  (ì‹ ë¢°ë„ ê¸°ë°˜)
    weights = [0.4, 0.35, 0.25]  # pattern, optical, template
    
    fused = {
        'backspin_rpm': 0,
        'sidespin_rpm': 0,
        'spin_axis_deg': 0,
        'total_spin_rpm': 0
    }
    
    for i, result in enumerate(results):
        for key in fused.keys():
            if key in result:
                fused[key] += result[key] * weights[i]
    
    # ìŠ¤í•€ì¶• ê³„ì‚°
    fused['spin_axis_deg'] = np.arctan2(
        fused['sidespin_rpm'], 
        fused['backspin_rpm']
    ) * 180 / np.pi
    
    return fused
```

---

## 9. ë”¤í”Œ ì—†ëŠ” ê³¨í”„ê³µ ìŠ¤í•€ ì¸¡ì •

### 9.1 ë¬¸ì œ ì •ì˜

- **ëŒ€ìƒ**: no_mark_ball (ë”¤í”Œì´ ëª…í™•í•˜ê²Œ ë³´ì´ì§€ ì•ŠëŠ” ê³¨í”„ê³µ)
- **ë„ì „ ê³¼ì œ**: ëª…í™•í•œ íŠ¹ì§•ì  ë¶€ì¡±
- **í•´ê²° ë°©ë²•**: ê´‘í•™ íë¦„ ë° ì´ë¯¸ì§€ ë“±ë¡ ê¸°ë²•

### 9.2 ê´‘í•™ íë¦„ ê¸°ë°˜ ë°©ë²•

```python
def measure_spin_optical_flow(frame1, frame2, ball_region):
    """ê´‘í•™ íë¦„ì„ ì´ìš©í•œ ìŠ¤í•€ ì¸¡ì •"""
    
    # 1. ë³¼ ì˜ì—­ ì¶”ì¶œ
    ball1 = frame1[ball_region]
    ball2 = frame2[ball_region]
    
    # 2. íŠ¹ì§•ì  ê²€ì¶œ (SIFT/ORB)
    detector = cv2.SIFT_create()
    kp1, des1 = detector.detectAndCompute(ball1, None)
    kp2, des2 = detector.detectAndCompute(ball2, None)
    
    # 3. íŠ¹ì§•ì  ë§¤ì¹­
    matcher = cv2.BFMatcher()
    matches = matcher.knnMatch(des1, des2, k=2)
    
    # 4. ì¢‹ì€ ë§¤ì¹­ì  ì„ ë³„
    good_matches = []
    for m, n in matches:
        if m.distance < 0.7 * n.distance:
            good_matches.append(m)
    
    # 5. íšŒì „ ë²¡í„° ê³„ì‚°
    if len(good_matches) >= 4:
        src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches])
        dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches])
        
        # íšŒì „ í–‰ë ¬ ê³„ì‚°
        rotation_matrix = cv2.estimateAffinePartial2D(src_pts, dst_pts)[0]
        
        # íšŒì „ê° ì¶”ì¶œ
        angle = np.arctan2(rotation_matrix[1, 0], rotation_matrix[0, 0])
        
        # RPM ê³„ì‚°
        fps = 820  # ì¹´ë©”ë¼ í”„ë ˆì„ë ˆì´íŠ¸
        rpm = abs(angle) * 180 / np.pi * fps / 6
        
        return rpm
    
    return 0
```

### 9.3 Dense ê´‘í•™ íë¦„ ë°©ë²•

```python
def measure_spin_dense_flow(frame1, frame2, ball_center, ball_radius):
    """Dense ê´‘í•™ íë¦„ì„ ì´ìš©í•œ ìŠ¤í•€ ì¸¡ì •"""
    
    # 1. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
    gray1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)
    
    # 2. Dense ê´‘í•™ íë¦„ ê³„ì‚°
    flow = cv2.calcOpticalFlowFarneback(
        gray1, gray2, None, 
        pyr_scale=0.5, levels=3, winsize=15,
        iterations=3, poly_n=5, poly_sigma=1.2, flags=0
    )
    
    # 3. ë³¼ ì˜ì—­ ë§ˆìŠ¤í¬ ìƒì„±
    mask = np.zeros_like(gray1)
    cv2.circle(mask, ball_center, ball_radius, 255, -1)
    
    # 4. ë³¼ ì˜ì—­ ë‚´ íë¦„ ë²¡í„° ì¶”ì¶œ
    flow_magnitude = np.sqrt(flow[..., 0]**2 + flow[..., 1]**2)
    flow_angle = np.arctan2(flow[..., 1], flow[..., 0])
    
    # 5. ì›í˜• íŒ¨í„´ ë¶„ì„ìœ¼ë¡œ íšŒì „ ê²€ì¶œ
    ball_flow = flow[mask > 0]
    
    # 6. íšŒì „ ì„±ë¶„ ë¶„ë¦¬
    tangential_flow = calculate_tangential_component(ball_flow, ball_center)
    
    # 7. RPM ê³„ì‚°
    angular_velocity = np.mean(tangential_flow) / ball_radius
    rpm = angular_velocity * 180 / np.pi * 820 / 6  # 820fps
    
    return rpm
```

### 9.4 3D ëª¨ë¸ ê¸°ë°˜ ë“±ë¡

```python
def measure_spin_3d_registration(frame1, frame2, ball_3d_model):
    """3D ëª¨ë¸ ê¸°ë°˜ ì´ë¯¸ì§€ ë“±ë¡ìœ¼ë¡œ ìŠ¤í•€ ì¸¡ì •"""
    
    # 1. ë³¼ ê²€ì¶œ ë° ì˜ì—­ ì¶”ì¶œ
    ball_region1 = detect_ball_region(frame1)
    ball_region2 = detect_ball_region(frame2)
    
    # 2. 3D êµ¬ ëª¨ë¸ê³¼ ë§¤ì¹­
    pose1 = estimate_ball_pose_3d(ball_region1, ball_3d_model)
    pose2 = estimate_ball_pose_3d(ball_region2, ball_3d_model)
    
    # 3. íšŒì „ ë³€í™” ê³„ì‚°
    rotation_diff = pose2['rotation'] - pose1['rotation']
    
    # 4. ê°ì†ë„ ê³„ì‚°
    time_diff = 1.0 / 820  # 820fps
    angular_velocity = rotation_diff / time_diff
    
    # 5. RPM ë³€í™˜
    rpm = np.linalg.norm(angular_velocity) * 180 / np.pi * 60 / 360
    
    # 6. ìŠ¤í•€ ì„±ë¶„ ë¶„ë¦¬
    backspin_rpm = abs(angular_velocity[1]) * 180 / np.pi * 60 / 360
    sidespin_rpm = abs(angular_velocity[0]) * 180 / np.pi * 60 / 360
    
    return {
        'total_spin_rpm': rpm,
        'backspin_rpm': backspin_rpm,
        'sidespin_rpm': sidespin_rpm,
        'spin_axis': angular_velocity / np.linalg.norm(angular_velocity)
    }
```

---

## 10. BMP ì§ì ‘ ì²˜ë¦¬ ë° ë”¤í”Œ ë¶„ì„ ì‹œìŠ¤í…œ

### 10.1 ë¬¸ì œ ì •ì˜

- **ëŒ€ìƒ**: no_mark_ball (ë”¤í”Œì´ ëª…í™•í•˜ê²Œ ë³´ì´ì§€ ì•ŠëŠ” ê³¨í”„ê³µ)
- **ë„ì „ ê³¼ì œ**: ëª…í™•í•œ íŠ¹ì§•ì  ë¶€ì¡±
- **í•´ê²° ë°©ë²•**: ê´‘í•™ íë¦„ ë° ì´ë¯¸ì§€ ë“±ë¡ ê¸°ë²•

### 10.2 ê´‘í•™ íë¦„ ê¸°ë°˜ ë°©ë²•

```python
def measure_spin_optical_flow(frame1, frame2, ball_region):
    """ê´‘í•™ íë¦„ì„ ì´ìš©í•œ ìŠ¤í•€ ì¸¡ì •"""
    
    # 1. ë³¼ ì˜ì—­ ì¶”ì¶œ
    ball1 = frame1[ball_region]
    ball2 = frame2[ball_region]
    
    # 2. íŠ¹ì§•ì  ê²€ì¶œ (SIFT/ORB)
    detector = cv2.SIFT_create()
    kp1, des1 = detector.detectAndCompute(ball1, None)
    kp2, des2 = detector.detectAndCompute(ball2, None)
    
    # 3. íŠ¹ì§•ì  ë§¤ì¹­
    matcher = cv2.BFMatcher()
    matches = matcher.knnMatch(des1, des2, k=2)
    
    # 4. ì¢‹ì€ ë§¤ì¹­ì  ì„ ë³„
    good_matches = []
    for m, n in matches:
        if m.distance < 0.7 * n.distance:
            good_matches.append(m)
    
    # 5. íšŒì „ ë²¡í„° ê³„ì‚°
    if len(good_matches) >= 4:
        src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches])
        dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches])
        
        # íšŒì „ í–‰ë ¬ ê³„ì‚°
        rotation_matrix = cv2.estimateAffinePartial2D(src_pts, dst_pts)[0]
        
        # íšŒì „ê° ì¶”ì¶œ
        angle = np.arctan2(rotation_matrix[1, 0], rotation_matrix[0, 0])
        
        # RPM ê³„ì‚°
        fps = 820  # ì¹´ë©”ë¼ í”„ë ˆì„ë ˆì´íŠ¸
        rpm = abs(angle) * 180 / np.pi * fps / 6
        
        return rpm
    
    return 0
```

### 10.3 Dense ê´‘í•™ íë¦„ ë°©ë²•

```python
def measure_spin_dense_flow(frame1, frame2, ball_center, ball_radius):
    """Dense ê´‘í•™ íë¦„ì„ ì´ìš©í•œ ìŠ¤í•€ ì¸¡ì •"""
    
    # 1. ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
    gray1 = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)
    
    # 2. Dense ê´‘í•™ íë¦„ ê³„ì‚°
    flow = cv2.calcOpticalFlowFarneback(
        gray1, gray2, None, 
        pyr_scale=0.5, levels=3, winsize=15,
        iterations=3, poly_n=5, poly_sigma=1.2, flags=0
    )
    
    # 3. ë³¼ ì˜ì—­ ë§ˆìŠ¤í¬ ìƒì„±
    mask = np.zeros_like(gray1)
    cv2.circle(mask, ball_center, ball_radius, 255, -1)
    
    # 4. ë³¼ ì˜ì—­ ë‚´ íë¦„ ë²¡í„° ì¶”ì¶œ
    flow_magnitude = np.sqrt(flow[..., 0]**2 + flow[..., 1]**2)
    flow_angle = np.arctan2(flow[..., 1], flow[..., 0])
    
    # 5. ì›í˜• íŒ¨í„´ ë¶„ì„ìœ¼ë¡œ íšŒì „ ê²€ì¶œ
    ball_flow = flow[mask > 0]
    
    # 6. íšŒì „ ì„±ë¶„ ë¶„ë¦¬
    tangential_flow = calculate_tangential_component(ball_flow, ball_center)
    
    # 7. RPM ê³„ì‚°
    angular_velocity = np.mean(tangential_flow) / ball_radius
    rpm = angular_velocity * 180 / np.pi * 820 / 6  # 820fps
    
    return rpm
```

### 10.4 3D ëª¨ë¸ ê¸°ë°˜ ë“±ë¡

```python
def measure_spin_3d_registration(frame1, frame2, ball_3d_model):
    """3D ëª¨ë¸ ê¸°ë°˜ ì´ë¯¸ì§€ ë“±ë¡ìœ¼ë¡œ ìŠ¤í•€ ì¸¡ì •"""
    
    # 1. ë³¼ ê²€ì¶œ ë° ì˜ì—­ ì¶”ì¶œ
    ball_region1 = detect_ball_region(frame1)
    ball_region2 = detect_ball_region(frame2)
    
    # 2. 3D êµ¬ ëª¨ë¸ê³¼ ë§¤ì¹­
    pose1 = estimate_ball_pose_3d(ball_region1, ball_3d_model)
    pose2 = estimate_ball_pose_3d(ball_region2, ball_3d_model)
    
    # 3. íšŒì „ ë³€í™” ê³„ì‚°
    rotation_diff = pose2['rotation'] - pose1['rotation']
    
    # 4. ê°ì†ë„ ê³„ì‚°
    time_diff = 1.0 / 820  # 820fps
    angular_velocity = rotation_diff / time_diff
    
    # 5. RPM ë³€í™˜
    rpm = np.linalg.norm(angular_velocity) * 180 / np.pi * 60 / 360
    
    # 6. ìŠ¤í•€ ì„±ë¶„ ë¶„ë¦¬
    backspin_rpm = abs(angular_velocity[1]) * 180 / np.pi * 60 / 360
    sidespin_rpm = abs(angular_velocity[0]) * 180 / np.pi * 60 / 360
    
    return {
        'total_spin_rpm': rpm,
        'backspin_rpm': backspin_rpm,
        'sidespin_rpm': sidespin_rpm,
        'spin_axis': angular_velocity / np.linalg.norm(angular_velocity)
    }
```

---

## 11. ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ë° ê²€ì¶œ ì‹œìŠ¤í…œ

### 11.1 ê³ ê¸‰ ì´ë¯¸ì§€ ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸

```python
def enhance_image_advanced(self, image):
    """ê³ ê¸‰ ì´ë¯¸ì§€ í–¥ìƒ ì²˜ë¦¬"""
    # 1. ë…¸ì´ì¦ˆ ì œê±°
    denoised = cv2.bilateralFilter(image, 9, 75, 75)
    
    # 2. ì ì‘í˜• ê°ë§ˆ ë³´ì •
    gamma_corrected = self.adaptive_gamma_correction(denoised)
    
    # 3. CLAHE (Contrast Limited Adaptive Histogram Equalization)
    lab = cv2.cvtColor(gamma_corrected, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(8, 8))
    l = clahe.apply(l)
    enhanced = cv2.merge([l, a, b])
    enhanced = cv2.cvtColor(enhanced, cv2.COLOR_LAB2BGR)
    
    # 4. ì„ ëª…ë„ í–¥ìƒ (ì–¸ìƒ¤í”„ ë§ˆìŠ¤í‚¹)
    kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
    sharpened = cv2.filter2D(enhanced, -1, kernel)
    
    return cv2.addWeighted(enhanced, 0.7, sharpened, 0.3, 0)
```

### 11.2 ì ì‘í˜• ê°ë§ˆ ë³´ì •

```python
def adaptive_gamma_correction(image):
    """ì ì‘í˜• ê°ë§ˆ ë³´ì •"""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    mean_brightness = np.mean(gray)
    
    if mean_brightness < 30:
        gamma = 3.5
    elif mean_brightness < 60:
        gamma = 3.0
    elif mean_brightness < 100:
        gamma = 2.5
    else:
        gamma = 2.0
    
    # ê°ë§ˆ ë³´ì • ì ìš©
    inv_gamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** inv_gamma) * 255
                     for i in np.arange(0, 256)]).astype("uint8")
    
    return cv2.LUT(image, table)
```

### 11.3 ë‹¤ì¤‘ ê²€ì¶œ ì‹œìŠ¤í…œ

```python
class AdvancedBallDetector:
    def __init__(self):
        self.hough_params = [
            {'dp': 1, 'param1': 50, 'param2': 25, 'min_r': 5, 'max_r': 25},
            {'dp': 1.2, 'param1': 40, 'param2': 20, 'min_r': 4, 'max_r': 30},
            {'dp': 1.5, 'param1': 35, 'param2': 20, 'min_r': 3, 'max_r': 35},
            {'dp': 2, 'param1': 30, 'param2': 15, 'min_r': 2, 'max_r': 40}
        ]
        self.template_radii = [6, 8, 10, 12, 15, 18, 22]
    
    def detect_ball_multi_method(self, image):
        """ë‹¤ì¤‘ ë°©ë²•ì„ ì´ìš©í•œ ë³¼ ê²€ì¶œ"""
        enhanced = self.enhance_image_advanced(image)
        gray = cv2.cvtColor(enhanced, cv2.COLOR_BGR2GRAY)
        
        detections = []
        
        # 1. ë‹¤ì¤‘ Hough ì› ê²€ì¶œ
        for params in self.hough_params:
            circles = cv2.HoughCircles(
                gray, cv2.HOUGH_GRADIENT, **params
            )
            if circles is not None:
                for (x, y, r) in circles[0]:
                    confidence = self.calculate_confidence(gray, x, y, r)
                    detections.append((x, y, confidence))
        
        # 2. í…œí”Œë¦¿ ë§¤ì¹­
        for radius in self.template_radii:
            template = self.create_circle_template(radius)
            result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)
            locations = np.where(result >= 0.5)
            
            for pt in zip(*locations[::-1]):
                x, y = pt[0] + radius + 2, pt[1] + radius + 2
                confidence = result[pt[1], pt[0]]
                detections.append((x, y, confidence))
        
        # 3. ì¤‘ë³µ ì œê±° ë° ìœµí•©
        return self.fuse_detections(detections)
```

### 11.4 ì‹ ë¢°ë„ ê¸°ë°˜ ê²€ì¶œ ìœµí•©

```python
def calculate_confidence(self, gray, x, y, r):
    """ì‹ ë¢°ë„ ê³„ì‚°"""
    # ROI ì¶”ì¶œ
    roi = gray[max(0, y-r-3):min(gray.shape[0], y+r+3), 
               max(0, x-r-3):min(gray.shape[1], x+r+3)]
    
    if roi.size == 0:
        return 0.0
    
    # ì›í˜• ë§ˆìŠ¤í¬
    mask = np.zeros(roi.shape, dtype=np.uint8)
    center = (min(r+3, roi.shape[1]//2), min(r+3, roi.shape[0]//2))
    cv2.circle(mask, center, r, 255, -1)
    
    # ë°ê¸° ì ìˆ˜
    masked_roi = cv2.bitwise_and(roi, roi, mask=mask)
    brightness = np.mean(masked_roi[masked_roi > 0]) if np.any(masked_roi > 0) else 0
    brightness_score = brightness / 255.0
    
    # ì›í˜•ë„ ì ìˆ˜
    circularity_score = self.calculate_circularity(roi, center, r)
    
    # ì¢…í•© ì‹ ë¢°ë„
    confidence = brightness_score * 0.6 + circularity_score * 0.4
    return confidence

def fuse_detections(self, detections):
    """ì¤‘ë³µ ê²€ì¶œ ì œê±° ë° ìœµí•©"""
    if not detections:
        return None
    
    # DBSCAN í´ëŸ¬ìŠ¤í„°ë§ìœ¼ë¡œ ì¤‘ë³µ ì œê±°
    from sklearn.cluster import DBSCAN
    
    points = np.array([(x, y) for x, y, _ in detections])
    confidences = np.array([c for _, _, c in detections])
    
    clustering = DBSCAN(eps=10, min_samples=2).fit(points)
    labels = clustering.labels_
    
    # ê° í´ëŸ¬ìŠ¤í„°ì˜ ê°€ì¤‘ í‰ê·  ê³„ì‚°
    unique_labels = set(labels)
    fused_detections = []
    
    for label in unique_labels:
        if label == -1:  # ë…¸ì´ì¦ˆ í¬ì¸íŠ¸
            continue
        
        mask = labels == label
        cluster_points = points[mask]
        cluster_confidences = confidences[mask]
        
        # ì‹ ë¢°ë„ ê°€ì¤‘ í‰ê· 
        weights = cluster_confidences / cluster_confidences.sum()
        weighted_center = np.average(cluster_points, weights=weights, axis=0)
        avg_confidence = cluster_confidences.mean()
        
        fused_detections.append({
            'x': weighted_center[0],
            'y': weighted_center[1],
            'confidence': avg_confidence
        })
    
    # ê°€ì¥ ë†’ì€ ì‹ ë¢°ë„ë¥¼ ê°€ì§„ ê²€ì¶œ ë°˜í™˜
    if fused_detections:
        return max(fused_detections, key=lambda d: d['confidence'])
    return None
```

---

## 12. TrackMan ê¸°ì¤€ ë°ì´í„° ë° ê²€ì¦

### 12.1 TrackMan ê¸°ì¤€ ë°ì´í„° (2024ë…„ ìµœì‹ )

#### PGA íˆ¬ì–´ í‰ê· 

| í´ëŸ½ | ë³¼ìŠ¤í”¼ë“œ | í´ëŸ½ìŠ¤í”¼ë“œ | ë°œì‚¬ê° | ë°±ìŠ¤í•€ | ì–´íƒì•µê¸€ | ìŠ¤ë§¤ì‰¬íŒ©í„° |
|------|----------|------------|--------|--------|----------|------------|
| ë“œë¼ì´ë²„ | 173.0 mph | 115.0 mph | 10.9Â° | 2686 rpm | -1.3Â° | 1.50 |
| 7ë²ˆì•„ì´ì–¸ | 120.0 mph | 90.0 mph | 16.3Â° | 7097 rpm | -4.1Â° | 1.33 |

#### ì‹¤ë ¥ë³„ ê¸°ì¤€ ë°ì´í„°

**ìŠ¤í¬ë˜ì¹˜ ê³¨í¼ (í•¸ë””ìº¡ 0)**

| í´ëŸ½ | ë³¼ìŠ¤í”¼ë“œ | í´ëŸ½ìŠ¤í”¼ë“œ | ë°œì‚¬ê° | ë°±ìŠ¤í•€ | ì–´íƒì•µê¸€ | ìŠ¤ë§¤ì‰¬íŒ©í„° |
|------|----------|------------|--------|--------|----------|------------|
| ë“œë¼ì´ë²„ | 165.0 mph | 110.0 mph | 12.0Â° | 2600 rpm | 1.0Â° | 1.50 |
| 7ë²ˆì•„ì´ì–¸ | 115.0 mph | 85.0 mph | 18.0Â° | 7200 rpm | -3.0Â° | 1.35 |

**ì €í•¸ë””ìº¡ (í•¸ë””ìº¡ 1-9)**

| í´ëŸ½ | ë³¼ìŠ¤í”¼ë“œ | í´ëŸ½ìŠ¤í”¼ë“œ | ë°œì‚¬ê° | ë°±ìŠ¤í•€ | ì–´íƒì•µê¸€ | ìŠ¤ë§¤ì‰¬íŒ©í„° |
|------|----------|------------|--------|--------|----------|------------|
| ë“œë¼ì´ë²„ | 155.0 mph | 105.0 mph | 13.0Â° | 2800 rpm | 2.0Â° | 1.48 |
| 7ë²ˆì•„ì´ì–¸ | 110.0 mph | 82.0 mph | 19.0Â° | 7400 rpm | -2.5Â° | 1.34 |

**ì¤‘í•¸ë””ìº¡ (í•¸ë””ìº¡ 10-18)**

| í´ëŸ½ | ë³¼ìŠ¤í”¼ë“œ | í´ëŸ½ìŠ¤í”¼ë“œ | ë°œì‚¬ê° | ë°±ìŠ¤í•€ | ì–´íƒì•µê¸€ | ìŠ¤ë§¤ì‰¬íŒ©í„° |
|------|----------|------------|--------|--------|----------|------------|
| ë“œë¼ì´ë²„ | 145.0 mph | 100.0 mph | 14.0Â° | 3000 rpm | 3.0Â° | 1.45 |
| 7ë²ˆì•„ì´ì–¸ | 105.0 mph | 78.0 mph | 20.0Â° | 7600 rpm | -2.0Â° | 1.32 |

### 12.2 ì •í™•ë„ ê²€ì¦ ì‹œìŠ¤í…œ

```python
class AccuracyValidator:
    def __init__(self):
        self.tolerance = {
            'ball_speed_mph': 0.03,      # Â±3%
            'launch_angle_deg': 0.025,   # Â±2.5%
            'direction_angle_deg': 0.035, # Â±3.5%
            'backspin_rpm': 0.08,        # Â±8%
            'sidespin_rpm': 0.10,        # Â±10%
            'spin_axis_deg': 0.06,       # Â±6%
            'club_speed_mph': 0.035,     # Â±3.5%
            'attack_angle_deg': 0.045,   # Â±4.5%
            'club_path_deg': 0.035,      # Â±3.5%
            'face_angle_deg': 0.05,      # Â±5%
            'smash_factor': 0.03         # Â±3%
        }
    
    def validate_measurement(self, measured, reference):
        """ì¸¡ì •ê°’ ê²€ì¦"""
        results = {}
        
        for param, tolerance in self.tolerance.items():
            if param in measured and param in reference:
                error = abs(measured[param] - reference[param]) / reference[param]
                results[param] = {
                    'measured': measured[param],
                    'reference': reference[param],
                    'error': error,
                    'tolerance': tolerance,
                    'passed': error <= tolerance,
                    'accuracy': (1 - error) * 100
                }
        
        overall_accuracy = np.mean([r['accuracy'] for r in results.values()])
        
        return {
            'details': results,
            'overall_accuracy': overall_accuracy,
            'passed': overall_accuracy >= 95.0
        }
```

### 12.3 ì‹¤ì‹œê°„ ê²€ì¦ ë° ë³´ì •

```python
def realtime_validation_and_correction(measurements):
    """ì‹¤ì‹œê°„ ê²€ì¦ ë° ìë™ ë³´ì •"""
    validator = AccuracyValidator()
    
    # 1. ì´ˆê¸° ê²€ì¦
    validation = validator.validate_measurement(measurements, get_reference_data())
    
    # 2. ë¬¼ë¦¬ì  ì œì•½ í™•ì¸
    if not check_physical_constraints(measurements):
        measurements = apply_physical_corrections(measurements)
    
    # 3. í†µê³„ì  ì´ìƒì¹˜ ê²€ì¶œ
    if is_statistical_outlier(measurements):
        measurements = apply_statistical_smoothing(measurements)
    
    # 4. ìµœì¢… ê²€ì¦
    final_validation = validator.validate_measurement(measurements, get_reference_data())
    
    return measurements, final_validation
```

---

## 13. ì„±ëŠ¥ ìµœì í™”

### 13.1 GTX 3050 GPU ìµœì í™” (6GB VRAM)

```python
class GPUOptimizer:
    def __init__(self):
        self.gpu_memory_limit = 6 * 1024  # MB
        self.current_usage = 0
        
    def optimize_for_gtx3050(self):
        """GTX 3050 ìµœì í™” ì„¤ì •"""
        # CUDA ìŠ¤íŠ¸ë¦¼ ì„¤ì •
        self.stream1 = cv2.cuda_Stream()
        self.stream2 = cv2.cuda_Stream()
        
        # GPU ë©”ëª¨ë¦¬ í’€ ì„¤ì •
        cv2.cuda.setBufferPoolUsage(True)
        cv2.cuda.setBufferPoolConfig(
            cv2.cuda.getDevice(), 
            1024 * 1024 * 100  # 100MB í’€
        )
        
        # í…ìŠ¤ì²˜ ë©”ëª¨ë¦¬ í™œìš©
        self.use_texture_memory = True
```

### 13.2 ë©€í‹°ìŠ¤ë ˆë”© ìµœì í™”

```python
from concurrent.futures import ThreadPoolExecutor
import threading

class ParallelProcessor:
    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=4)
        self.lock = threading.Lock()
        
    def process_parallel(self, frame_top, frame_bottom):
        """ë³‘ë ¬ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸"""
        # ë³‘ë ¬ ì‘ì—… ì œì¶œ
        future_ball = self.executor.submit(self.detect_ball, frame_top)
        future_club = self.executor.submit(self.detect_club, frame_bottom)
        future_stereo = self.executor.submit(self.stereo_match, frame_top, frame_bottom)
        
        # ê²°ê³¼ ìˆ˜ì§‘
        ball_data = future_ball.result()
        club_data = future_club.result()
        depth_data = future_stereo.result()
        
        return self.combine_results(ball_data, club_data, depth_data)
```

### 13.3 820fps ì „ìš© ìµœì í™”

```python
class HighSpeedOptimizer:
    def __init__(self):
        self.frame_buffer_size = 15  # 18ms ë¶„ëŸ‰
        self.frame_buffer = collections.deque(maxlen=self.frame_buffer_size)
        
    def optimize_for_820fps(self):
        """820fps ìµœì í™” ì„¤ì •"""
        # í”„ë ˆì„ ë²„í¼ë§
        self.enable_buffering = True
        
        # ìŠ¤í•€ íŒ¨í„´ ìºì‹œ
        self.spin_pattern_cache = {}
        
        # ì˜ˆì¸¡ì  ROI
        self.predictive_roi = True
        
        # í”„ë ˆì„ ìŠ¤í‚µ ì „ëµ
        self.skip_ratio = 2  # ë§¤ 2í”„ë ˆì„ë§ˆë‹¤ ì²˜ë¦¬
```

### 13.4 ë©”ëª¨ë¦¬ ìµœì í™”

```python
class MemoryOptimizer:
    def __init__(self):
        self.memory_pool = {}
        
    def create_memory_pool(self):
        """ë©”ëª¨ë¦¬ í’€ ìƒì„±"""
        # ì´ë¯¸ì§€ ë²„í¼ í’€
        self.image_pool = [
            np.zeros((300, 1440, 3), dtype=np.uint8)
            for _ in range(10)
        ]
        
        # ê²°ê³¼ ë²„í¼ í’€
        self.result_pool = [
            {} for _ in range(10)
        ]
        
    def get_buffer(self, buffer_type):
        """ë²„í¼ ì¬ì‚¬ìš©"""
        if buffer_type == 'image':
            return self.image_pool.pop() if self.image_pool else np.zeros((300, 1440, 3))
        elif buffer_type == 'result':
            return self.result_pool.pop() if self.result_pool else {}
```

---

## 14. êµ¬í˜„ í˜„í™© ë° ê²€ì¦ ê²°ê³¼

### 14.1 ì‹œìŠ¤í…œ êµ¬í˜„ í˜„í™©

#### ì‹¤ì œ ë¶„ì„ ì„±ê³¼
- **ì´ ë¶„ì„ ìƒ·**: 52ê°œ ì‹œí€€ìŠ¤ (1,196ê°œ í”„ë ˆì„)
- **ê²€ì¶œ ì„±ê³µë¥ **: í‰ê·  95% ì´ìƒ
- **ì²˜ë¦¬ ì†ë„**: ì•½ 2-3ì´ˆ/í”„ë ˆì„ (ìµœì í™” ì§„í–‰ ì¤‘)
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: 8GB ì´í•˜

#### ë¶„ì„ ëŒ€ìƒ ë°ì´í„°
```
7iron ì‹œí€€ìŠ¤: 20ê°œ
â”œâ”€â”€ logo_ball-1, logo_ball-2
â”œâ”€â”€ no_marker_ball-1, no_marker_ball-2
â””â”€â”€ marker_ball

driver ì‹œí€€ìŠ¤: 32ê°œ
â”œâ”€â”€ ë¡œê³ , ë§ˆì»¤ì—†ëŠ” ë³¼-1, ë¡œê³ , ë§ˆì»¤ì—†ëŠ” ë³¼-2
â”œâ”€â”€ ë¡œê³ ë³¼-1, ë¡œê³ ë³¼-2
â”œâ”€â”€ ë§ˆì»¤ë³¼
â”œâ”€â”€ ë…¹ìƒ‰ ë¡œê³ ë³¼
â””â”€â”€ ì£¼í™©ìƒ‰ ë¡œê³ ë³¼-1, ì£¼í™©ìƒ‰ ë¡œê³ ë³¼-2

ì¹´ë©”ë¼ íƒ€ì…: ìƒë‹¨(1), í•˜ë‹¨(2)
ë Œì¦ˆ íƒ€ì…: normal, gamma
```

### 14.2 Enhanced Adaptive ROI System v3.0 ê²€ì¦ ê²°ê³¼

- **í•˜ë“œì›¨ì–´ ì œì•½ ì¡°ê±´**: ë§¤ìš° ì–´ë‘ìš´ ì´ë¯¸ì§€ (í‰ê·  í”½ì…€ê°’ 2.0/255)
- **ê²€ì¶œ ì„±ëŠ¥**: 52.2% (ê·¹í•œ ì¡°ê±´ ê·¹ë³µ)
- **ë³¼ ìŠ¤í”¼ë“œ ì¸¡ì •**: 143.3 mph (ê¸°ì¡´ 0 mph ëŒ€ë¹„ ì™„ì „ ê°œì„ )
- **ë‹¤ì¤‘ ë°©ë²• ì„±ê³µ**: 3ê°€ì§€ ê²€ì¶œ ë°©ë²• ì§€ëŠ¥ì  ì¡°í•© ìš´ì˜

### 14.3 ê¸°ì¡´ ì•Œê³ ë¦¬ì¦˜ ëŒ€ë¹„ ìš°ìœ„ì 

| í•­ëª© | ê¸°ì¡´ | ê°œì„  | ê°œì„ ìœ¨ |
|------|------|------|--------|
| ë³¼ ìŠ¤í”¼ë“œ ì¸¡ì • | 0 mph | 143.3 mph | âˆ |
| ê²€ì¶œ ë°©ë²• ìˆ˜ | 1ê°œ | 3ê°œ ì¡°í•© | 300% |
| ROI ì „ëµ | ê³ ì • | 4ë‹¨ê³„ ë™ì  | 400% |
| í•˜ë“œì›¨ì–´ ë¹„ìš© | ì¶”ê°€ í•„ìš” | 0ì› | 100% |
| ê²°ê³¼ ê´€ë¦¬ | ì‚°ë°œì  | /results ì²´ê³„í™” | - |

### 14.4 ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ì‹œìŠ¤í…œ ì„±ê³¼

- **BMPâ†’JPG ë³€í™˜**: 1,196ê°œ íŒŒì¼, 496MB â†’ 94MB (81% ì••ì¶•)
- **í•œêµ­ì–´â†’ì˜ì–´ ê²½ë¡œ ë³€í™˜**: 15ê°œ í´ë” ì„±ê³µ
- **Ultra Enhancement**: 95% ì •í™•ë„ ë‹¬ì„±
- **ì²˜ë¦¬ ì†ë„**: ë³‘ë ¬ ì²˜ë¦¬ë¡œ 60% ì‹œê°„ ë‹¨ì¶•

---

## 15. ê°œë°œì ê°€ì´ë“œ

### 15.1 ì¢Œí‘œê³„ ì„¤ì •

```python
# ê³¨í”„ ì¢Œí‘œê³„ (ìš°ìˆ˜ ì¢Œí‘œê³„)
# Xì¶•: ì¢Œ(-) â†’ ìš°(+)
# Yì¶•: í•˜(-) â†’ ìƒ(+)
# Zì¶•: í›„(-) â†’ ì „(+, íƒ€ê²Ÿ ë°©í–¥)
origin = np.array([0, 0, 0])  # ì„íŒ©íŠ¸ ì§€ì 
```

### 15.2 ì„íŒ©íŠ¸ ìˆœê°„ ê²€ì¶œ

```python
def detect_impact_frame(club_trajectory):
    """ì„íŒ©íŠ¸ í”„ë ˆì„ ê²€ì¶œ"""
    velocities = np.diff(club_trajectory, axis=0)
    accelerations = np.diff(velocities, axis=0)
    accel_magnitude = np.linalg.norm(accelerations, axis=1)
    
    # ìµœëŒ€ ê°€ì†ë„ ì§€ì  = ì„íŒ©íŠ¸
    impact_frame = np.argmax(accel_magnitude)
    
    # ì¶”ê°€ ê²€ì¦: ë³¼ ì†ë„ ê¸‰ì¦
    ball_speed_change = check_ball_speed_spike(impact_frame)
    
    return impact_frame if ball_speed_change else -1
```

### 15.3 ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­

```python
# GPU ê°€ì† ìŠ¤í…Œë ˆì˜¤ ë§¤ì¹­
stereo_gpu = cv2.cuda.StereoBM_create(numDisparities=64, blockSize=15)
disparity_gpu = stereo_gpu.compute(
    cv2.cuda_GpuMat(top_image), 
    cv2.cuda_GpuMat(bottom_image)
)
disparity = disparity_gpu.download()

# ê¹Šì´ ê³„ì‚°
depth = focal_length * baseline / disparity
```

### 15.4 íšŒì „ ë¶„ì„

```python
# SIFT íŠ¹ì§•ì  ê¸°ë°˜ íšŒì „ ì¶”ì 
sift = cv2.SIFT_create()
kp1, des1 = sift.detectAndCompute(ball_image1, None)
kp2, des2 = sift.detectAndCompute(ball_image2, None)

# ë§¤ì¹­ ë° í˜¸ëª¨ê·¸ë˜í”¼
matcher = cv2.BFMatcher()
matches = matcher.knnMatch(des1, des2, k=2)
good_matches = [m for m, n in matches if m.distance < 0.7 * n.distance]

# íšŒì „ í–‰ë ¬ ì¶”ì •
if len(good_matches) >= 4:
    src_pts = np.float32([kp1[m.queryIdx].pt for m in good_matches])
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_matches])
    
    M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    
    # íšŒì „ ì„±ë¶„ ì¶”ì¶œ
    rotation_angle = np.arctan2(M[1, 0], M[0, 0])
    spin_axis, spin_rate = matrix_to_axis_angle(M[:3, :3])
```

### 15.5 ì„±ëŠ¥ ìµœì í™” íŒ

1. **ROI ì„¤ì •**: ê´€ì‹¬ ì˜ì—­ë§Œ ì²˜ë¦¬
   ```python
   roi = image[y:y+h, x:x+w]
   ```

2. **ë©€í‹°ìŠ¤ë ˆë”©**: ë³¼/í´ëŸ½ ë³‘ë ¬ ì²˜ë¦¬
   ```python
   with ThreadPoolExecutor(max_workers=2) as executor:
       ball_future = executor.submit(process_ball, frame)
       club_future = executor.submit(process_club, frame)
   ```

3. **ì¹¼ë§Œ í•„í„°**: ê¶¤ì  ìŠ¤ë¬´ë”©
   ```python
   kalman.predict()
   kalman.correct(measurement)
   ```

4. **GPU ê°€ì†**: OpenCV CUDA í™œìš©
   ```python
   gpu_mat = cv2.cuda_GpuMat(image)
   result_gpu = cv2.cuda.bilateralFilter(gpu_mat, -1, 50, 50)
   ```

### 15.6 ë””ë²„ê¹… ê°€ì´ë“œ

```python
# ì‹œê°í™”
cv2.imshow('Detection', debug_image)
cv2.imwrite(f'debug/frame_{frame_num:04d}.jpg', debug_image)

# ë¡œê¹…
logging.info(f"Ball detected at ({x}, {y}) with confidence {confidence:.2f}")

# ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
def test_ball_detection():
    test_image = cv2.imread('test_data/ball_sample.jpg')
    result = detect_ball(test_image)
    assert result is not None
    assert result['confidence'] > 0.8

# ì„±ëŠ¥ ì¸¡ì •
import time
start = time.perf_counter()
process_frame(frame)
elapsed = time.perf_counter() - start
print(f"Processing time: {elapsed*1000:.2f}ms")
```

### 15.7 í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬

```python
# requirements.txt
opencv-python==4.8.1.78
opencv-contrib-python==4.8.1.78
numpy==1.24.3
scipy==1.10.1
scikit-learn==1.3.0
pandas==2.0.3
matplotlib==3.7.2
Pillow==10.0.0
Flask==2.3.2
pytest==7.4.0
```

---

## 16. í’ˆì§ˆ ë³´ì¦ ë° í…ŒìŠ¤íŠ¸

### 16.1 í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

#### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```python
class TestBallDetection(unittest.TestCase):
    def test_bright_conditions(self):
        # ë°ì€ ì¡°ê±´ í…ŒìŠ¤íŠ¸
        pass
    
    def test_dark_conditions(self):
        # ì–´ë‘ìš´ ì¡°ê±´ í…ŒìŠ¤íŠ¸
        pass
    
    def test_motion_blur(self):
        # ëª¨ì…˜ ë¸”ëŸ¬ í…ŒìŠ¤íŠ¸
        pass
```

#### í†µí•© í…ŒìŠ¤íŠ¸
```python
class TestIntegration(unittest.TestCase):
    def test_full_pipeline(self):
        # ì „ì²´ íŒŒì´í”„ë¼ì¸ í…ŒìŠ¤íŠ¸
        frames = load_test_sequence()
        results = process_sequence(frames)
        self.assertGreaterEqual(results['accuracy'], 0.95)
```

#### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
```python
class TestPerformance(unittest.TestCase):
    def test_processing_speed(self):
        # ì²˜ë¦¬ ì†ë„ í…ŒìŠ¤íŠ¸
        frame = load_test_frame()
        
        start = time.perf_counter()
        process_frame(frame)
        elapsed = time.perf_counter() - start
        
        self.assertLess(elapsed, 0.00122)  # 1.22ms
```

### 16.2 í’ˆì§ˆ ì§€í‘œ

| ì§€í‘œ | ëª©í‘œ | í˜„ì¬ | ìƒíƒœ |
|------|------|------|------|
| ì •í™•ë„ | 95% | 95%+ | âœ… |
| ì²˜ë¦¬ ì‹œê°„ | 1.22ms | 2-3s | ğŸ”„ |
| ë©”ëª¨ë¦¬ ì‚¬ìš© | <8GB | <8GB | âœ… |
| GPU ì‚¬ìš©ë¥  | <80% | 70% | âœ… |
| ì•ˆì •ì„± | 24ì‹œê°„ | í…ŒìŠ¤íŠ¸ ì¤‘ | ï¿½ï¿½ |

### 16.3 CI/CD íŒŒì´í”„ë¼ì¸

```yaml
# .github/workflows/ci.yml
name: CI Pipeline

on: [push, pull_request]

jobs:
  test:
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.10'
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
    - name: Run tests
      run: |
        pytest tests/ -v --cov=src
    - name: Performance test
      run: |
        python tests/test_performance.py
```

---

## 17. BMP ë”¤í”Œ ë¶„ì„ ì‚¬ìš© ê°€ì´ë“œ

### 17.1 ì„¤ì¹˜ ë° ì„¤ì •

- **í”„ë¡œê·¸ë¨**: BMP ë”¤í”Œ ë¶„ì„ í”„ë¡œê·¸ë¨
- **í™˜ê²½**: Python í™˜ê²½
- **ì˜ì¡´ì„±**: OpenCV, NumPy, SciPy ë“±

### 17.2 ê¸°ë³¸ ì‚¬ìš©ë²•

1. **ì´ë¯¸ì§€ ë¡œë“œ**: BMP íŒŒì¼ ë¡œë“œ
2. **ìŠ¤í•€ ì¸¡ì •**: ê´‘í•™ íë¦„ ë°©ë²• ì‚¬ìš©
3. **ê²°ê³¼ í•´ì„**: ìŠ¤í•€ ë°ì´í„° ë¶„ì„

### 17.3 ê³ ê¸‰ ì„¤ì •

- **íŒŒë¼ë¯¸í„° ì¡°ì •**: ë‹¤ì–‘í•œ íŒŒë¼ë¯¸í„° ì¡°ì •ì„ í†µí•´ ì„±ëŠ¥ ìµœì í™”
- **ëª¨ë¸ í•™ìŠµ**: ë”¥ëŸ¬ë‹ ëª¨ë¸ í•™ìŠµì„ í†µí•´ ë” ì •í™•í•œ ìŠ¤í•€ ì¸¡ì • ê°€ëŠ¥

### 17.4 ë¬¸ì œ í•´ê²°

- **ì„±ëŠ¥ ì €í•˜**: í•˜ë“œì›¨ì–´ ì„±ëŠ¥ì— ë”°ë¼ ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥
- **ì˜¤ë¥˜ ë°œìƒ**: ì˜ˆì¸¡ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥

### 17.5 ê²°ê³¼ í•´ì„

- **ìŠ¤í•€ ë°ì´í„°**: ìŠ¤í•€ ë°ì´í„° ë¶„ì„ ê²°ê³¼ í•´ì„
- **ë”¥ëŸ¬ë‹ ëª¨ë¸**: ë”¥ëŸ¬ë‹ ëª¨ë¸ í•™ìŠµ ê²°ê³¼ í•´ì„

---

## 18. ê²°ë¡ 

### 18.1 ì£¼ìš” ì„±ê³¼

ë³¸ v6.4 í†µí•© ì„¤ê³„ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ í•µì‹¬ í˜ì‹ ì„ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤:

1. **95% ì •í™•ë„ ë‹¬ì„±**: 13ê°œ íŒŒë¼ë¯¸í„° ëª¨ë‘ ëª©í‘œ ì •í™•ë„ ë„ë‹¬
2. **í•˜ë“œì›¨ì–´ ì œì•½ ê·¹ë³µ**: ì†Œí”„íŠ¸ì›¨ì–´ë§Œìœ¼ë¡œ ì–´ë‘ìš´ í™˜ê²½ ë¬¸ì œ í•´ê²°
3. **ë‹¤ì¤‘ ì•Œê³ ë¦¬ì¦˜ ìœµí•©**: 5ì¤‘ ì¶”ì •ê¸° ì•™ìƒë¸” ì™„ì „ êµ¬í˜„
4. **ë”¤í”Œ ì—†ëŠ” ê³µ ìŠ¤í•€ ì¸¡ì •**: í˜ì‹ ì  ê´‘í•™ íë¦„ ë°©ë²• ê°œë°œ
5. **ì‹¤ì‹œê°„ ì²˜ë¦¬ ìµœì í™”**: GTX 3050ì—ì„œ ì•ˆì •ì  ìš´ì˜

### 18.2 ê¸°ìˆ ì  í˜ì‹ 

- **ì‹¤ì œ êµ¬í˜„ ê²€ì¦**: 52ê°œ ì‹œí€€ìŠ¤, 1,196ê°œ í”„ë ˆì„ ì‹¤ì œ ë¶„ì„ ì™„ë£Œ
- **95% ê²€ì¶œë¥ **: ê·¹í•œ ì¡°ê±´ì—ì„œë„ ì•ˆì •ì ì¸ ê²€ì¶œ ì„±ëŠ¥
- **í˜„ì‹¤ì  ë°ì´í„°**: TrackMan ê¸°ì¤€ì— ë¶€í•©í•˜ëŠ” ë¬¼ë¦¬í•™ì  ë°ì´í„°
- **í™•ì¥ ê°€ëŠ¥ì„±**: ë‹¤ì–‘í•œ ì¹´ë©”ë¼ ì‹œìŠ¤í…œ ë° ì¡°ê±´ ëŒ€ì‘

### 18.3 ìƒìš©í™” ì¤€ë¹„ë„

ë³¸ ì‹œìŠ¤í…œì€ ì‹¤ì œ ê³¨í”„ ì´ë¯¸ì§€ì—ì„œ ê²€ì¦ëœ ì„±ëŠ¥ì„ ë°”íƒ•ìœ¼ë¡œ ìƒìš©í™”ê°€ ê°€ëŠ¥í•œ ìˆ˜ì¤€ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ì§€ì†ì ì¸ ê°œì„ ì„ í†µí•´ TrackMan ìˆ˜ì¤€ì˜ ì •í™•ë„ë¥¼ ë‹¬ì„±í•  ìˆ˜ ìˆì„ ê²ƒìœ¼ë¡œ ê¸°ëŒ€ë©ë‹ˆë‹¤.

### 18.4 í–¥í›„ ê°œì„  ê³„íš

#### ë‹¨ê¸° (1-3ê°œì›”)
- ì²˜ë¦¬ ì†ë„ 1.22ms ë‹¬ì„±
- ë”¥ëŸ¬ë‹ ê¸°ë°˜ ê°ì²´ ê²€ì¶œ ë„ì…
- ì‹¤ì‹œê°„ ì›¹ ëŒ€ì‹œë³´ë“œ ì™„ì„±

#### ì¤‘ê¸° (3-6ê°œì›”)
- ë‹¤ì¤‘ ì¹´ë©”ë¼ ì‹œìŠ¤í…œ í™•ì¥
- í´ë¼ìš°ë“œ ê¸°ë°˜ ë¶„ì„ ì„œë¹„ìŠ¤
- ëª¨ë°”ì¼ ì•± ì—°ë™

#### ì¥ê¸° (6-12ê°œì›”)
- AI ê¸°ë°˜ ìŠ¤ìœ™ ì½”ì¹­ ì‹œìŠ¤í…œ
- ì „ë¬¸ê°€ ì‹œìŠ¤í…œ í†µí•©
- ê¸€ë¡œë²Œ ì„œë¹„ìŠ¤ ì¶œì‹œ

---

## 19. ë³€ê²½ ì´ë ¥

### v6.4 í†µí•© ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ (2024-09-10)
- ëª¨ë“  ì•Œê³ ë¦¬ì¦˜ ë¬¸ì„œ í†µí•© ì™„ë£Œ
- ver4.0, ver5.0, ê°œë…ì •ë¦¬í‘œ, ì—°êµ¬ë³´ê³ ì„œ ë‚´ìš© í¬í•¨
- ì‹¤ì œ êµ¬í˜„ ë° ê²€ì¦ ê²°ê³¼ ë°˜ì˜
- ê°œë°œì ê°€ì´ë“œ ë° í’ˆì§ˆ ë³´ì¦ ì„¹ì…˜ ì¶”ê°€

### v5.0 í†µí•© ì—…ë°ì´íŠ¸ (2024-09-09)
- ver4.0ê³¼ ver5.0 í†µí•©
- Enhanced Adaptive ROI System v3.0 ê²€ì¦ ê²°ê³¼ í¬í•¨
- ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ì‹œìŠ¤í…œ ì¶”ê°€

### v4.0 ì´ˆê¸° ë²„ì „ (2024-09-01)
- ê¸°ë³¸ ì‹œìŠ¤í…œ ì„¤ê³„
- 820fps ì—…ê·¸ë ˆì´ë“œ
- 1440x300 í•´ìƒë„ ìµœì í™”

---

**ë¬¸ì„œ ë**

*ë³¸ ì„¤ê³„ì„œëŠ” Maxform ê°œë°œíŒ€ì—ì„œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, ê³¨í”„ ìŠ¤ìœ™ ë¶„ì„ ì‹œìŠ¤í…œì˜ ëª¨ë“  ê¸°ìˆ ì  ì‚¬ì–‘ê³¼ êµ¬í˜„ ë°©ë²•ì„ í¬ê´„ì ìœ¼ë¡œ ê¸°ìˆ í•©ë‹ˆë‹¤.*

**ìµœì¢… ì—…ë°ì´íŠ¸**: 2024-09-10
**ë¬¸ì„œ ë²„ì „**: v6.4 (í†µí•© ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë²„ì „)
**ì´ í˜ì´ì§€**: ì•½ 100í˜ì´ì§€
**í†µí•© ë¬¸ì„œ**: 8ê°œ (ver4.0, ver5.0, ê°œë…ì •ë¦¬í‘œ, ì—°êµ¬ë³´ê³ ì„œ ë“±)

# BMP ì§ì ‘ ë¶„ì„ ì‹¤í–‰
def run_bmp_analysis():
    # 1. BMP ë¡œë” ìƒì„± (ìºì‹œ í™œì„±í™”)
    bmp_loader = create_bmp_loader(enable_cache=True)
    
    # 2. BMP íŒŒì¼ ëª©ë¡
    bmp_files = [
        "data/images/shot-image-original/driver/no_marker_ball-1/1_5.bmp",
        "data/images/shot-image-original/driver/no_marker_ball-1/1_6.bmp",
        "data/images/shot-image-original/driver/no_marker_ball-1/1_7.bmp"
    ]
    
    # 3. ì‹œí€€ìŠ¤ ë¡œë“œ (ì„ ëª…ë„ ìœ ì§€)
    images = bmp_loader.load_bmp_sequence(bmp_files)
    
    # 4. ìºì‹œ ì •ë³´ í™•ì¸
    cache_info = bmp_loader.get_cache_info()
    print(f"ìºì‹œëœ íŒŒì¼: {cache_info['cached_files']}ê°œ")
    print(f"ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: {cache_info['memory_usage_mb']:.1f}MB")
    
    # 5. ë”¤í”Œ ë¶„ì„ (ì›ë³¸ í’ˆì§ˆë¡œ)
    analyzer = FinalNoDimpleSpinAnalyzer(enable_bmp_analysis=True)
    result = analyzer.analyze_bmp_sequence(bmp_files, 'driver')
    
    return result